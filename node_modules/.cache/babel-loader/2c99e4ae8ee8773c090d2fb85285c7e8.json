{"ast":null,"code":"// Use binary search on the array to find the index of the gift\nexport default ((arr, gift_id) => {\n  // set pointers for the ends of where we are looking and get the middle of those pointers\n  let start = 0;\n  let end = arr.length - 1;\n  let curr_index = Math.round((end - start) / 2);\n  if (arr[start].id === gift_id) return start;\n  if (arr[end].id === gift_id) return end; // check to see if gift at index is gift we are looking for\n  // if it is not, move the pointer and keep looking until we find it\n\n  while (arr[curr_index].id !== gift_id) {\n    console.log(\"start:\".concat(arr[start].id, \", index: \").concat(start));\n    console.log(\"middle:\".concat(arr[curr_index].id, \", index: \").concat(curr_index));\n    console.log(\"end:\".concat(arr[end].id, \", index: \").concat(end)); // if the wanted gift id is smaller then the gift id at current index: make end pointer current index\n\n    if (gift_id <= arr[curr_index].id) end = curr_index; // otherwise: make start pointer current index\n    else start = curr_index; // update current index with updated pointers\n\n    curr_index = start + Math.round((end - start) / 2);\n  } //once the while loop ends, we should have found the index of the wanted gift and will return it. \n\n\n  return curr_index;\n});","map":{"version":3,"sources":["/Users/loremenius/Documents/Git/familiy-wishlist/src/redux/reducers/functions/findGiftIndex.js"],"names":["arr","gift_id","start","end","length","curr_index","Math","round","id","console","log"],"mappings":"AAAA;AACA,gBAAe,CAACA,GAAD,EAAMC,OAAN,KAAgB;AAC3B;AACA,MAAIC,KAAK,GAAG,CAAZ;AACA,MAAIC,GAAG,GAAGH,GAAG,CAACI,MAAJ,GAAW,CAArB;AACA,MAAIC,UAAU,GAAGC,IAAI,CAACC,KAAL,CAAW,CAACJ,GAAG,GAACD,KAAL,IAAY,CAAvB,CAAjB;AAEA,MAAIF,GAAG,CAACE,KAAD,CAAH,CAAWM,EAAX,KAAkBP,OAAtB,EAA+B,OAAOC,KAAP;AAC/B,MAAIF,GAAG,CAACG,GAAD,CAAH,CAASK,EAAT,KAAgBP,OAApB,EAA6B,OAAOE,GAAP,CAPF,CAS3B;AACA;;AACA,SAAMH,GAAG,CAACK,UAAD,CAAH,CAAgBG,EAAhB,KAAuBP,OAA7B,EAAqC;AACjCQ,IAAAA,OAAO,CAACC,GAAR,iBAAqBV,GAAG,CAACE,KAAD,CAAH,CAAWM,EAAhC,sBAA8CN,KAA9C;AACAO,IAAAA,OAAO,CAACC,GAAR,kBAAsBV,GAAG,CAACK,UAAD,CAAH,CAAgBG,EAAtC,sBAAoDH,UAApD;AACAI,IAAAA,OAAO,CAACC,GAAR,eAAmBV,GAAG,CAACG,GAAD,CAAH,CAASK,EAA5B,sBAA0CL,GAA1C,GAHiC,CAIjC;;AACA,QAAGF,OAAO,IAAID,GAAG,CAACK,UAAD,CAAH,CAAgBG,EAA9B,EAAkCL,GAAG,GAAGE,UAAN,CAAlC,CACA;AADA,SAEKH,KAAK,GAAGG,UAAR,CAP4B,CAQjC;;AACAA,IAAAA,UAAU,GAAGH,KAAK,GAAGI,IAAI,CAACC,KAAL,CAAW,CAACJ,GAAG,GAACD,KAAL,IAAY,CAAvB,CAArB;AACH,GArB0B,CAuB3B;;;AACA,SAAOG,UAAP;AAEH,CA1BD","sourcesContent":["// Use binary search on the array to find the index of the gift\nexport default (arr, gift_id)=>{\n    // set pointers for the ends of where we are looking and get the middle of those pointers\n    let start = 0;\n    let end = arr.length-1\n    let curr_index = Math.round((end-start)/2);\n\n    if (arr[start].id === gift_id) return start\n    if (arr[end].id === gift_id) return end \n\n    // check to see if gift at index is gift we are looking for\n    // if it is not, move the pointer and keep looking until we find it\n    while(arr[curr_index].id !== gift_id){\n        console.log(`start:${arr[start].id}, index: ${start}`);\n        console.log(`middle:${arr[curr_index].id}, index: ${curr_index}`);\n        console.log(`end:${arr[end].id}, index: ${end}`);\n        // if the wanted gift id is smaller then the gift id at current index: make end pointer current index\n        if(gift_id <= arr[curr_index].id) end = curr_index;\n        // otherwise: make start pointer current index\n        else start = curr_index;\n        // update current index with updated pointers\n        curr_index = start + Math.round((end-start)/2);\n    }\n\n    //once the while loop ends, we should have found the index of the wanted gift and will return it. \n    return curr_index\n\n}"]},"metadata":{},"sourceType":"module"}